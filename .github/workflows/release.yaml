name: NPM Release

# Unified workflow for all NPM releases:
# - Alpha: On merge to develop branch
# - Beta: On merge to main branch
# - Production: On GitHub release creation
#
# Version Management:
# - Uses lerna version and publish commands with consistent patterns
# - Commits version changes to git FIRST, then publishes to NPM
# - Prevents infinite loops with [skip ci] in commit messages
# - Proper error handling without masking critical failures

on:
  push:
    branches:
      - develop # Triggers alpha releases
      - main # Triggers beta releases
    paths-ignore:
      - '**/*.md'
      - 'docs/**'
      - '.github/**/*.md'
      - 'LICENSE'
      - '.gitignore'
      - '.dockerignore'
      - '**/*.example'
      - '.vscode/**'
      - '.devcontainer/**'
  release:
    types: [created] # Triggers production releases
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Manual release type'
        required: true
        type: choice
        options:
          - alpha
          - beta
          - latest

jobs:
  release:
    runs-on: ubuntu-latest
    # Skip if commit message contains [skip ci]
    if: ${{ !contains(github.event.head_commit.message || '', '[skip ci]') }}

    permissions:
      contents: write
      packages: write
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # If triggered by a release, we're in detached HEAD state
          # Create a temporary branch for Lerna to work with
          if [[ "${{ github.event_name }}" == "release" ]]; then
            echo "Creating temporary branch from release tag..."
            git checkout -b temp-release-branch
          fi

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '23.3.0'
          registry-url: 'https://registry.npmjs.org'

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: '1.2.21'

      - name: Install dependencies
        run: bun install

      # Determine release type and version
      - name: Determine release type
        id: release_type
        run: |
          if [[ "${{ github.event_name }}" == "release" ]]; then
            echo "type=latest" >> $GITHUB_OUTPUT
            echo "dist_tag=latest" >> $GITHUB_OUTPUT
            # Extract version from tag (remove 'v' prefix if present)
            VERSION="${{ github.event.release.tag_name }}"
            VERSION="${VERSION#v}"
            echo "version=${VERSION}" >> $GITHUB_OUTPUT
            echo "is_release_event=true" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "type=${{ github.event.inputs.release_type }}" >> $GITHUB_OUTPUT
            echo "dist_tag=${{ github.event.inputs.release_type }}" >> $GITHUB_OUTPUT
            echo "is_release_event=false" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            echo "type=alpha" >> $GITHUB_OUTPUT
            echo "dist_tag=alpha" >> $GITHUB_OUTPUT
            echo "is_release_event=false" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "type=beta" >> $GITHUB_OUTPUT
            echo "dist_tag=beta" >> $GITHUB_OUTPUT
            echo "is_release_event=false" >> $GITHUB_OUTPUT
          fi

      # Version Management
      - name: Version packages
        id: version
        run: |
          RELEASE_TYPE="${{ steps.release_type.outputs.type }}"
          CURRENT_VERSION=$(node -p "require('./lerna.json').version")
          echo "Current version: ${CURRENT_VERSION}"

          if [[ "${{ github.event_name }}" == "release" ]]; then
            # For production releases from GitHub release
            VERSION="${{ steps.release_type.outputs.version }}"
            echo "Setting version to ${VERSION}"
            bunx lerna version ${VERSION} \
              --force-publish \
              --yes \
              --no-private \
              --no-git-tag-version \
              --no-push
          elif [[ "${RELEASE_TYPE}" == "alpha" ]]; then
            # Alpha prerelease
            bunx lerna version prerelease \
              --preid alpha \
              --force-publish \
              --yes \
              --no-private \
              --no-git-tag-version \
              --no-push
          elif [[ "${RELEASE_TYPE}" == "beta" ]]; then
            # Beta prerelease - handle transition from alpha or existing beta
            # Check if we're transitioning from alpha to beta
            if [[ "${CURRENT_VERSION}" == *"-alpha."* ]]; then
              # Transitioning from alpha to beta
              # First check if a beta version already exists
              BASE_VERSION=$(echo "${CURRENT_VERSION}" | sed 's/-alpha\..*//')
              EXISTING_BETA_TAGS=$(git tag -l "v${BASE_VERSION}-beta.*" | sort -V | tail -n 1)
              
              if [[ -n "${EXISTING_BETA_TAGS}" ]]; then
                # Beta version already exists, get the latest beta number
                LATEST_BETA_VERSION=${EXISTING_BETA_TAGS#v}
                echo "Found existing beta version: ${LATEST_BETA_VERSION}"
                echo "Continuing from existing beta version..."
                
                # Set to the existing beta version first
                bunx lerna version ${LATEST_BETA_VERSION} \
                  --force-publish \
                  --yes \
                  --no-private \
                  --no-git-tag-version \
                  --no-push
                
                # Then bump to the next beta
                bunx lerna version prerelease \
                  --preid beta \
                  --force-publish \
                  --yes \
                  --no-private \
                  --no-git-tag-version \
                  --no-push
              else
                # No existing beta, start at beta.0
                bunx lerna version prerelease \
                  --preid beta \
                  --force-publish \
                  --yes \
                  --no-private \
                  --no-git-tag-version \
                  --no-push
              fi
            else
              # Already on beta or another prerelease, just bump
              bunx lerna version prerelease \
                --preid beta \
                --force-publish \
                --yes \
                --no-private \
                --no-git-tag-version \
                --no-push
            fi
          elif [[ "${RELEASE_TYPE}" == "latest" ]]; then
            # Manual production release
            bunx lerna version patch \
              --force-publish \
              --yes \
              --no-private \
              --no-git-tag-version \
              --no-push
          fi

          # Get the new version
          VERSION=$(node -p "require('./lerna.json').version")
          echo "version=${VERSION}" >> $GITHUB_OUTPUT

      # Update lockfile after version changes
      - name: Update lockfile
        run: |
          bun install --no-frozen-lockfile

      # Commit and push version changes BEFORE building and publishing
      # This ensures git is the source of truth
      - name: Commit version changes
        id: commit
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          RELEASE_TYPE="${{ steps.release_type.outputs.type }}"

          # Stage all changes
          git add -A

          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "No changes to commit - this might indicate a problem"
            echo "has_changes=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Commit with [skip ci] to prevent infinite loop
          git commit -m "chore: release v${VERSION} (${RELEASE_TYPE}) [skip ci]"
          echo "has_changes=true" >> $GITHUB_OUTPUT
          echo "commit_sha=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT

      # Create and push git tag (only if not from a GitHub release)
      - name: Create git tag
        if: steps.release_type.outputs.is_release_event != 'true' && steps.commit.outputs.has_changes == 'true'
        id: tag
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          TAG_NAME="v${VERSION}"

          # Check if tag already exists
          if git rev-parse "${TAG_NAME}" >/dev/null 2>&1; then
            echo "âŒ Error: Tag ${TAG_NAME} already exists"
            echo "This indicates a version conflict that needs manual resolution"
            exit 1
          fi

          # Create the tag
          git tag "${TAG_NAME}"
          echo "tag_created=true" >> $GITHUB_OUTPUT
          echo "tag_name=${TAG_NAME}" >> $GITHUB_OUTPUT

      # Push changes to git (fails the workflow if it can't push)
      - name: Push to git
        if: steps.commit.outputs.has_changes == 'true'
        run: |
          # Determine target branch for push
          if [[ "${{ github.event_name }}" == "release" ]]; then
            # For GitHub releases, push to main branch
            TARGET_BRANCH="main"
            echo "Pushing changes to main branch..."
            
            # Push the changes to main branch
            if ! git push origin HEAD:${TARGET_BRANCH} --follow-tags; then
              echo "âŒ Error: Failed to push to git repository"
              echo "This could be due to:"
              echo "  - Protected branch restrictions"
              echo "  - Network issues"
              echo "  - Permission problems"
              echo ""
              echo "The version has been updated locally but not published."
              echo "Manual intervention required to resolve the git push issue."
              exit 1
            fi
          else
            # For other triggers, push to current branch
            if ! git push origin HEAD --follow-tags; then
              echo "âŒ Error: Failed to push to git repository"
              echo "This could be due to:"
              echo "  - Protected branch restrictions"
              echo "  - Network issues"
              echo "  - Permission problems"
              echo ""
              echo "The version has been updated locally but not published."
              echo "Manual intervention required to resolve the git push issue."
              exit 1
            fi
          fi

          echo "âœ… Successfully pushed version changes and tags to git"

      # Build packages with correct version numbers
      # Only happens AFTER git operations succeed
      - name: Build packages
        run: |
          echo "Building packages with version v${{ steps.version.outputs.version }}..."
          bun run build

      # Publish to NPM (only after git operations succeed)
      - name: Publish to NPM
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
        run: |
          DIST_TAG="${{ steps.release_type.outputs.dist_tag }}"

          # Configure npm for authentication
          echo "//registry.npmjs.org/:_authToken=${NODE_AUTH_TOKEN}" > ~/.npmrc

          # Publish with appropriate dist-tag
          if ! bunx lerna publish from-package \
            --dist-tag ${DIST_TAG} \
            --force-publish \
            --yes \
            --no-verify-access; then
            
            echo "âŒ Error: Failed to publish to NPM"
            echo ""
            echo "Git has been updated with version v${{ steps.version.outputs.version }}"
            echo "but the packages were not published to NPM."
            echo ""
            echo "To recover:"
            echo "  1. Fix the NPM publishing issue"
            echo "  2. Run 'npm run release:${DIST_TAG}' locally with proper credentials"
            echo "  3. Or re-run this workflow"
            exit 1
          fi

          echo "âœ… Successfully published to NPM with dist-tag: ${DIST_TAG}"

      # Create GitHub Release for alpha/beta (not for production, as it already exists)
      - name: Create GitHub release
        if: github.event_name != 'release' && steps.release_type.outputs.type != 'latest' && steps.tag.outputs.tag_created == 'true'
        uses: softprops/action-gh-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.tag.outputs.tag_name }}
          name: ${{ steps.tag.outputs.tag_name }}
          body: |
            ${{ steps.release_type.outputs.type == 'alpha' && 'ğŸš€ Alpha Release' || 'ğŸ”µ Beta Release' }}

            **Version:** `${{ steps.tag.outputs.tag_name }}`
            **Channel:** `${{ steps.release_type.outputs.dist_tag }}`

            ### Quick Start

            Install the CLI globally to get started:
            ```bash
            bun i -g @elizaos/cli@${{ steps.release_type.outputs.dist_tag }}
            ```

            Or add packages to your project:
            ```bash
            bun add @elizaos/core@${{ steps.release_type.outputs.dist_tag }}
            bun add @elizaos/plugin-bootstrap@${{ steps.release_type.outputs.dist_tag }}
            ```

            ---

            > **Note:** This is a ${{ steps.release_type.outputs.type }} release. Production releases use the `latest` tag and are triggered by GitHub releases on tags matching `v*.*.*`.
          draft: false
          prerelease: true

      - name: Summary
        if: always()
        run: |
          echo "# ğŸ“¦ Release Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: v${{ steps.version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Type**: ${{ steps.release_type.outputs.type }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Dist Tag**: ${{ steps.release_type.outputs.dist_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Trigger**: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          if [[ "${{ steps.commit.outputs.has_changes }}" == "true" ]]; then
            echo "- **Commit SHA**: ${{ steps.commit.outputs.commit_sha }}" >> $GITHUB_STEP_SUMMARY
          fi
          if [[ "${{ steps.tag.outputs.tag_created }}" == "true" ]]; then
            echo "- **Tag**: ${{ steps.tag.outputs.tag_name }}" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Quick Start" >> $GITHUB_STEP_SUMMARY
          echo "Install the CLI globally:" >> $GITHUB_STEP_SUMMARY
          echo '```bash' >> $GITHUB_STEP_SUMMARY
          echo "bun i -g @elizaos/cli@${{ steps.release_type.outputs.dist_tag }}" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Or add to your project:" >> $GITHUB_STEP_SUMMARY
          echo '```bash' >> $GITHUB_STEP_SUMMARY
          echo "bun add @elizaos/core@${{ steps.release_type.outputs.dist_tag }}" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

      # Handle failure - create issue if the workflow failed
      - name: Create issue content file
        if: failure() && steps.version.outputs.version
        run: |
          cat > /tmp/issue-content.md << 'EOF'
          The release workflow failed for version v${{ steps.version.outputs.version }}.

          **Details:**
          - Release Type: ${{ steps.release_type.outputs.type }}
          - Workflow Run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          - Triggered By: ${{ github.event_name }}
          - Git Changes Committed: ${{ steps.commit.outputs.has_changes || 'false' }}
          - Git Tag Created: ${{ steps.tag.outputs.tag_created || 'false' }}

          **Recovery Steps:**

          If git operations succeeded but NPM publish failed:
          - The version is already in git
          - Fix the NPM issue and run `npm run release:${{ steps.release_type.outputs.dist_tag }}` locally
          - Or re-run this workflow (it will skip git operations if no changes)

          If git operations failed:
          - No packages were published to NPM (safe state)
          - Fix the git issue (permissions, network, etc.)
          - Re-run the workflow

          **Action Required:**
          - Check the workflow logs for the specific failure point
          - Follow the appropriate recovery steps above
          EOF

      - name: Create failure issue
        if: failure() && steps.version.outputs.version
        uses: peter-evans/create-issue-from-file@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          title: 'Release Failed: v${{ steps.version.outputs.version }}'
          content-filepath: /tmp/issue-content.md
          labels: |
            bug
            release
            automated issue
